{
  "name": "Personal Nabla v2.0 - FINAL Production Ready",
  "nodes": [
    {
      "parameters": { "rule": { "interval": [ { "unit": "minutes", "number": 1 } ] } },
      "name": "Schedule Trigger", "type": "n8n-nodes-base.scheduleTrigger", "typeVersion": 1, "position": [ -460, 300 ]
    },
    {
      "parameters": { "documentId": "1vefhPJ87aI94tVi0HiON2yWbWFgXFBdMDT-mtgrK_ck", "sheetName": "Control Panel", "options": {} },
      "name": "Read Control Panel", "type": "n8n-nodes-base.googleSheets", "typeVersion": 1, "position": [ -260, 300 ],
      "credentials": { "googleSheetsOAuth2Api": { "id": "721866976686-601g6u27t34r6h1976avjbjiaphki53q.apps.googleusercontent.com", "name": "Google Sheets Credential" } }
    },
    {
      "parameters": { "batchSize": 1, "options": {} },
      "name": "SplitInBatches", "type": "n8n-nodes-base.splitInBatches", "typeVersion": 1, "position": [ -60, 300 ]
    },
    {
      "parameters": { "conditions": { "boolean": [ { "value1": "={{$json.isActive}}", "value2": true } ] } },
      "name": "If isActive", "type": "n8n-nodes-base.if", "typeVersion": 1, "position": [ 140, 300 ]
    },
    {
      "parameters": { "rules": { "rules": [ { "value1": "={{$json.chain}}", "operation": "equal", "value2": "solana" } ] } },
      "name": "Route by Chain", "type": "n8n-nodes-base.router", "typeVersion": 1, "position": [ 340, 300 ]
    },
    {
      "parameters": { "functionCode": "const chain = $json.chain;\nconst apiKey = 'OZfSvNcs2kskPPj5Ijvj8';\n$json.rpcUrl = `https://eth-${chain}.g.alchemy.com/v2/${apiKey}`;\nreturn $json;" },
      "name": "EVM: Build RPC URL", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 540, 100 ], "continueOnFail": true
    },
    {
      "parameters": { "rules": { "rules": [ { "value1": "={{$json.protocol}}", "operation": "equal", "value2": "aerodrome_v2" } ] } },
      "name": "EVM: Route by Protocol", "type": "n8n-nodes-base.router", "typeVersion": 1, "position": [ 740, 100 ]
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x3850c7bd\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get slot0", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 940, 100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x1a686502\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get liquidity", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 940, 200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x0dfe1681\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get token0", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, 100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0xd21220a7\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get token1", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, 200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0xd0c93a7c\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get tickSpacing", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, 300 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const token0_address = '0x' + $items(\"Uniswap: Get token0\")[0].json.result.slice(26);\nconst token1_address = '0x' + $items(\"Uniswap: Get token1\")[0].json.result.slice(26);\n$json.token0_address = token0_address;\n$json.token1_address = token1_address;\nreturn $json;" },
      "name": "Uniswap: Parse Token Addresses", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 1340, 200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.token0_address, \"data\": \"0x313ce567\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get token0 Decimals", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1540, 100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.token1_address, \"data\": \"0x313ce567\" }, \"latest\" ] }}" } ] } },
      "name": "Uniswap: Get token1 Decimals", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1540, 200 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const slot0_hex = $items(\"Uniswap: Get slot0\")[0].json.result;\nconst sqrtPriceX96 = BigInt('0x' + slot0_hex.slice(2, 66));\nconst tick = parseInt('0x' + slot0_hex.slice(66, 130), 16);\n\nconst liquidity_hex = $items(\"Uniswap: Get liquidity\")[0].json.result;\nconst liquidity = BigInt('0x' + liquidity_hex.slice(2));\n\nconst tick_spacing_hex = $items(\"Uniswap: Get tickSpacing\")[0].json.result;\nconst tick_spacing = parseInt(tick_spacing_hex, 16);\n\nconst token0_decimals_hex = $items(\"Uniswap: Get token0 Decimals\")[0].json.result;\nconst token1_decimals_hex = $items(\"Uniswap: Get token1 Decimals\")[0].json.result;\nconst token0_decimals = parseInt(token0_decimals_hex, 16);\nconst token1_decimals = parseInt(token1_decimals_hex, 16);\n\nconst price = (Number(sqrtPriceX96) / 2**96)**2;\n\nconst lower_tick = Math.floor(tick / tick_spacing) * tick_spacing;\nconst upper_tick = lower_tick + tick_spacing;\n\nconst lower_price = (1.0001**lower_tick) / (10**(token1_decimals - token0_decimals));\nconst upper_price = (1.0001**upper_tick) / (10**(token1_decimals - token0_decimals));\n\n$json.currentPrice = price;\n$json.liquidity = Number(liquidity);\n$json.lowerBound = lower_price;\n$json.upperBound = upper_price;\n\nreturn $json;" },
      "name": "Uniswap: Final Parse", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 1740, 200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x3850c7bd\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get slot0", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 940, -100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x1a686502\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get liquidity", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 940, -200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0x0dfe1681\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get token0", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, -100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0xd21220a7\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get token1", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, -200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.poolAddress, \"data\": \"0xd0c93a7c\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get tickSpacing", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1140, -300 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const token0_address = '0x' + $items(\"Aerodrome: Get token0\")[0].json.result.slice(26);\nconst token1_address = '0x' + $items(\"Aerodrome: Get token1\")[0].json.result.slice(26);\n$json.token0_address = token0_address;\n$json.token1_address = token1_address;\nreturn $json;" },
      "name": "Aerodrome: Parse Token Addresses", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 1340, -200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.token0_address, \"data\": \"0x313ce567\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get token0 Decimals", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1540, -100 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "={{$json.rpcUrl}}", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "eth_call" }, { "name": "params", "value": "={{ [ { \"to\": $json.token1_address, \"data\": \"0x313ce567\" }, \"latest\" ] }}" } ] } },
      "name": "Aerodrome: Get token1 Decimals", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 1540, -200 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const slot0_hex = $items(\"Aerodrome: Get slot0\")[0].json.result;\nconst sqrtPriceX96 = BigInt('0x' + slot0_hex.slice(2, 66));\nconst tick = parseInt('0x' + slot0_hex.slice(66, 130), 16);\n\nconst liquidity_hex = $items(\"Aerodrome: Get liquidity\")[0].json.result;\nconst liquidity = BigInt('0x' + liquidity_hex.slice(2));\n\nconst tick_spacing_hex = $items(\"Aerodrome: Get tickSpacing\")[0].json.result;\nconst tick_spacing = parseInt(tick_spacing_hex, 16);\n\nconst token0_decimals_hex = $items(\"Aerodrome: Get token0 Decimals\")[0].json.result;\nconst token1_decimals_hex = $items(\"Aerodrome: Get token1 Decimals\")[0].json.result;\nconst token0_decimals = parseInt(token0_decimals_hex, 16);\nconst token1_decimals = parseInt(token1_decimals_hex, 16);\n\nconst price = (Number(sqrtPriceX96) / 2**96)**2;\n\nconst lower_tick = Math.floor(tick / tick_spacing) * tick_spacing;\nconst upper_tick = lower_tick + tick_spacing;\n\nconst lower_price = (1.0001**lower_tick) / (10**(token1_decimals - token0_decimals));\nconst upper_price = (1.0001**upper_tick) / (10**(token1_decimals - token0_decimals));\n\n$json.currentPrice = price;\n$json.liquidity = Number(liquidity);\n$json.lowerBound = lower_price;\n$json.upperBound = upper_price;\n\nreturn $json;" },
      "name": "Aerodrome: Final Parse", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 1740, -200 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "https://solana-mainnet.g.alchemy.com/v2/oWbW_HujsV128NiaqaKpB", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "getAccountInfo" }, { "name": "params", "value": "={{ [$json.poolAddress, { \"encoding\": \"base64\" }] }}" } ] } },
      "name": "Solana: Get Pool Info", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 540, 500 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const { PublicKey } = require('@solana/web3.js');\nconst B = require('buffer/').Buffer;\n\nconst base64Data = $json.result.value.data[0];\nconst accountData = B.from(base64Data, 'base64');\n\n$json.liquidity = accountData.readBigUInt128LE(41);\n$json.sqrt_price = accountData.readBigUInt128LE(57);\n$json.tick_current_index = accountData.readInt32LE(73);\n$json.tick_spacing = accountData.readUInt16LE(33);\n\nconst tokenMintAOffset = 8;\nconst tokenMintBOffset = 8 + 32;\n$json.tokenMintA = new PublicKey(accountData.slice(tokenMintAOffset, tokenMintAOffset + 32)).toBase58();\n$json.tokenMintB = new PublicKey(accountData.slice(tokenMintBOffset, tokenMintBOffset + 32)).toBase58();\n\nreturn $json;" },
      "name": "Solana: Parse Pool & Get Mints", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 740, 500 ], "continueOnFail": true
    },
    {
      "parameters": { "url": "https://solana-mainnet.g.alchemy.com/v2/oWbW_HujsV128NiaqaKpB", "options": { "retryOnFail": true, "retryCount": 2, "retryDelay": 1000 }, "bodyParameters": { "parameters": [ { "name": "jsonrpc", "value": "2.0" }, { "name": "id", "value": 1 }, { "name": "method", "value": "getMultipleAccounts" }, { "name": "params", "value": "={{ [ [$json.tokenMintA, $json.tokenMintB], { \"encoding\": \"base64\" } ] }}" } ] } },
      "name": "Solana: Get Mint Infos", "type": "n8n-nodes-base.httpRequest", "typeVersion": 1, "position": [ 940, 500 ], "continueOnFail": true
    },
    {
      "parameters": { "functionCode": "const B = require('buffer/').Buffer;\n\nconst mintA_b64 = $json.result.value[0].data[0];\nconst mintB_b64 = $json.result.value[1].data[0];\n\nconst mintA_data = B.from(mintA_b64, 'base64');\nconst mintB_data = B.from(mintB_b64, 'base64');\n\nconst decimalsOffset = 44;\nconst token0_decimals = mintA_data.readUInt8(decimalsOffset);\nconst token1_decimals = mintB_data.readUInt8(decimalsOffset);\n\nconst price = (Number($json.sqrt_price) / 2**64)**2;\n\nconst lower_tick = Math.floor($json.tick_current_index / $json.tick_spacing) * $json.tick_spacing;\nconst upper_tick = lower_tick + $json.tick_spacing;\n\nconst priceFromTick = (tick) => (1.0001**tick) / (10**(token1_decimals - token0_decimals));\n\n$json.currentPrice = price;\n$json.liquidity = Number($json.liquidity);\n$json.lowerBound = priceFromTick(lower_tick);\n$json.upperBound = priceFromTick(upper_tick);\n\nreturn $json;" },
      "name": "Solana: Parse Mints & Calculate", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 1140, 500 ], "continueOnFail": true
    },
    {
      "parameters": {}, "name": "Merge", "type": "n8n-nodes-base.merge", "typeVersion": 1, "position": [ 1940, 300 ]
    },
    {
      "parameters": { "language": "python", "functionCode": "import json\nimport math\nfrom hyperliquid.info import Info\nfrom hyperliquid.exchange import Exchange\nfrom hyperliquid.utils import constants\n\nitems = self.get_input_data()\nresult_items = []\n\ncreds = self.get_credentials(\"MyHyperliquidApi\")\naddress = creds.get(\"walletAddress\")\nprivate_key = creds.get(\"privateKey\")\n\ninfo = Info(constants.MAINNET_API_URL, skip_ws=True)\nexchange = Exchange(private_key=private_key, base_url=constants.MAINNET_API_URL)\n\nfor item in items:\n    json_data = item.get(\"json\", {})\n    log_details = {}\n\n    try:\n        if 'currentPrice' not in json_data:\n            raise Exception(\"Upstream data fetching or parsing failed.\")\n\n        # --- Input Data ---\n        symbol = json_data.get(\"symbol\")\n        desired_leverage = float(json_data.get(\"desiredLeverage\"))\n        is_isolated = not bool(json_data.get(\"isIsolatedMargin\", True))\n        L = float(json_data.get(\"liquidity\"))\n        P = float(json_data.get(\"currentPrice\"))\n        Pa = float(json_data.get(\"lowerBound\"))\n        Pb = float(json_data.get(\"upperBound\"))\n\n        # --- Get Current State from Hyperliquid ---\n        user_state = info.user_state(address)\n        current_hedge_position = 0.0\n        for pos in user_state.get(\"assetPositions\", []):\n            if pos[\"position\"][\"coin\"] == symbol:\n                current_hedge_position = float(pos[\"position\"][\"szi\"])\n                break\n        \n        # --- NEW: Full Lifecycle Hedging Logic ---\n        target_hedge_size = 0.0\n        is_in_range = Pa < P < Pb\n        delta_lp = 0.0\n        gamma_lp = 0.0\n        amount_token0_in_lp = 0.0\n\n        if P <= Pa:\n            # CASE 1: Price is BELOW range. Target a full short hedge.\n            sqrt_pa = math.sqrt(Pa)\n            sqrt_pb = math.sqrt(Pb)\n            amount_token0_in_lp = L * ((sqrt_pb - sqrt_pa) / (sqrt_pa * sqrt_pb))\n            target_hedge_size = -amount_token0_in_lp\n            log_details[\"position_state\"] = \"Out of Range (Below)\"\n\n        elif P >= Pb:\n            # CASE 2: Price is ABOVE range. Target a flat hedge.\n            target_hedge_size = 0.0\n            log_details[\"position_state\"] = \"Out of Range (Above)\"\n\n        else: # (is_in_range)\n            # CASE 3: Price is INSIDE range. Use dynamic delta-neutral logic.\n            delta_lp = L * (math.sqrt(P / Pa) - math.sqrt(Pb / P))\n            target_hedge_size = -delta_lp\n            log_details[\"position_state\"] = \"In Range\"\n\n        # --- Universal Hedge Adjustment & Dead-band Logic ---\n        hedge_adjustment = target_hedge_size - current_hedge_position\n        is_hedge_required = False\n\n        if is_in_range:\n            gamma_lp = -L / (2 * math.pow(P, 1.5))\n            base_deadband_delta = 0.005\n            sensitivity_factor = 500.0\n            dynamic_deadband = base_deadband_delta / (1 + abs(gamma_lp) * sensitivity_factor)\n            if abs(hedge_adjustment) > dynamic_deadband:\n                is_hedge_required = True\n        else:\n            if abs(hedge_adjustment) > 0.001: \n                is_hedge_required = True\n\n        log_details.update({\"delta_lp\": delta_lp if is_in_range else (amount_token0_in_lp if P <= Pa else 0), \"gamma_lp\": gamma_lp, \"target_hedge_size\": target_hedge_size})\n\n        if is_hedge_required:\n            side = \"B\" if hedge_adjustment > 0 else \"A\"\n            order_size = abs(hedge_adjustment)\n\n            meta = info.meta()\n            asset_meta = next((asset for asset in meta[\"universe\"] if asset[\"name\"] == symbol), None)\n            \n            max_leverage = asset_meta[\"maxLeverage\"]\n            oracle_price = float(asset_meta[\"oraclePx\"])\n            actual_leverage = min(desired_leverage, max_leverage)\n\n            notional_value = order_size * oracle_price\n            required_margin = notional_value / actual_leverage\n\n            margin_summary = user_state[\"marginSummary\"]\n            available_capital = float(margin_summary[\"accountValue\"]) - float(margin_summary[\"totalMarginUsed\"])\n\n            if required_margin > available_capital:\n                log_details[\"action_taken\"] = \"Insufficient Capital\"\n                log_details[\"error_message\"] = f\"Required: ${required_margin:.2f}, Available: ${available_capital:.2f}\"\n            else:\n                exchange.update_leverage(actual_leverage, symbol, is_isolated)\n                order_result = exchange.order(symbol, side, order_size, None, {\"limit\": {\"tif\": \"Ioc\"}}, reduce_only=False)\n                log_details[\"action_taken\"] = f\"Hedge Adjustment Executed\"\n                log_details[\"trade_details\"] = order_result\n        else:\n            log_details[\"action_taken\"] = \"No Action Needed (Within dead-band)\"\n\n    except Exception as e:\n        if 'error' in json_data:\n            log_details[\"action_taken\"] = \"Error\"\n            log_details[\"error_message\"] = json_data['error']['message']\n        else:\n            log_details[\"action_taken\"] = \"Error\"\n            log_details[\"error_message\"] = str(e)\n\n    json_data[\"log_details\"] = log_details\n    result_items.append({\"json\": json_data})\n\nreturn result_items" },
      "name": "Core Hedging Logic", "type": "n8n-nodes-base.code", "typeVersion": 1, "position": [ 2140, 300 ]
    },
    {
      "parameters": { "documentId": "YOUR_GOOGLE_SHEET_ID", "sheetName": "Trade Tracker", "operation": "append", "columns": { "mappingMode": "mapByPosition", "value": { "0": "={{new Date().toISOString()}}", "1": "={{$json.poolAddress}}", "2": "={{$json.symbol}}", "3": "={{$json.log_details.action_taken}}", "4": "={{$json.log_details.delta_lp}}", "5": "={{$json.log_details.total_delta}}", "6": "={{$json.log_details.gamma_lp}}", "7": "={{JSON.stringify($json.log_details.trade_details)}}", "8": "={{$json.log_details.error_message}}" } }, "options": {} },
      "name": "Log to Trade Tracker", "type": "n8n-nodes-base.googleSheets", "typeVersion": 1, "position": [ 2340, 300 ],
      "credentials": { "googleSheetsOAuth2Api": { "id": "YOUR_GOOGLE_SHEETS_CREDENTIAL_ID", "name": "Google Sheets Credential" } }
    }
  ],
  "connections": {
    "Schedule Trigger": { "main": [ [ { "node": "Read Control Panel", "type": "main", "index": 0 } ] ] },
    "Read Control Panel": { "main": [ [ { "node": "SplitInBatches", "type": "main", "index": 0 } ] ] },
    "SplitInBatches": { "main": [ [ { "node": "If isActive", "type": "main", "index": 0 } ] ] },
    "If isActive": { "main": [ [ { "node": "Route by Chain", "type": "main", "index": 0 } ] ] },
    "Route by Chain": { "main": [ [ { "node": "EVM: Build RPC URL", "type": "main", "index": 0 } ], [ { "node": "Solana: Get Pool Info", "type": "main", "index": 0 } ] ] },
    "EVM: Build RPC URL": { "main": [ [ { "node": "EVM: Route by Protocol", "type": "main", "index": 0 } ] ] },
    "EVM: Route by Protocol": { "main": [ [ { "node": "Uniswap: Get slot0", "type": "main", "index": 0 } ], [ { "node": "Aerodrome: Get slot0", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get slot0": { "main": [ [ { "node": "Uniswap: Get liquidity", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get liquidity": { "main": [ [ { "node": "Uniswap: Get token0", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get token0": { "main": [ [ { "node": "Uniswap: Get token1", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get token1": { "main": [ [ { "node": "Uniswap: Get tickSpacing", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get tickSpacing": { "main": [ [ { "node": "Uniswap: Parse Token Addresses", "type": "main", "index": 0 } ] ] },
    "Uniswap: Parse Token Addresses": { "main": [ [ { "node": "Uniswap: Get token0 Decimals", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get token0 Decimals": { "main": [ [ { "node": "Uniswap: Get token1 Decimals", "type": "main", "index": 0 } ] ] },
    "Uniswap: Get token1 Decimals": { "main": [ [ { "node": "Uniswap: Final Parse", "type": "main", "index": 0 } ] ] },
    "Uniswap: Final Parse": { "main": [ [ { "node": "Merge", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get slot0": { "main": [ [ { "node": "Aerodrome: Get liquidity", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get liquidity": { "main": [ [ { "node": "Aerodrome: Get token0", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get token0": { "main": [ [ { "node": "Aerodrome: Get token1", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get token1": { "main": [ [ { "node": "Aerodrome: Get tickSpacing", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get tickSpacing": { "main": [ [ { "node": "Aerodrome: Parse Token Addresses", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Parse Token Addresses": { "main": [ [ { "node": "Aerodrome: Get token0 Decimals", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get token0 Decimals": { "main": [ [ { "node": "Aerodrome: Get token1 Decimals", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Get token1 Decimals": { "main": [ [ { "node": "Aerodrome: Final Parse", "type": "main", "index": 0 } ] ] },
    "Aerodrome: Final Parse": { "main": [ [ { "node": "Merge", "type": "main", "index": 0 } ] ] },
    "Solana: Get Pool Info": { "main": [ [ { "node": "Solana: Parse Pool & Get Mints", "type": "main", "index": 0 } ] ] },
    "Solana: Parse Pool & Get Mints": { "main": [ [ { "node": "Solana: Get Mint Infos", "type": "main", "index": 0 } ] ] },
    "Solana: Get Mint Infos": { "main": [ [ { "node": "Solana: Parse Mints & Calculate", "type": "main", "index": 0 } ] ] },
    "Solana: Parse Mints & Calculate": { "main": [ [ { "node": "Merge", "type": "main", "index": 0 } ] ] },
    "Merge": { "main": [ [ { "node": "Core Hedging Logic", "type": "main", "index": 0 } ] ] },
    "Core Hedging Logic": { "main": [ [ { "node": "Log to Trade Tracker", "type": "main", "index": 0 } ] ] }
  }
}